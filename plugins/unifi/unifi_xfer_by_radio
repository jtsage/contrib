#!/usr/bin/perl
# -*- perl -*-

=encoding utf8

=head1 NAME

unifi_xfer_by_radio - Munin plugin to display transfer stats per radio 
for each ubiquity / unifi device. (APs only)

=head1 APPLICABLE SYSTEMS

Currently is cabable of polling the unifi line (Ubiquity) from the unifi 
API - requires direct access to the controllor API.

=head1 CONFIGURATION

This script uses the multigraph functionality to generate many graphs.

For multigraph operation, the "internal" graphs will be one per device
with seperate metrics for packets, dropped / retries, and errors. The 
main graph shows packet totals for all devices.

If you are only interested in a single combined graph, you can set:

  [unifi_xfer_by_radio]
    env.multigraph no

You will also need to supply your API login details - you may do so 
per-plugin, or using a wildcard like below:

  [unifi_*]
    env.user Controller_Username
    # default is ubnt
    env.pass Controller_Password
    # default is ubnt
    env.host https://unifi.fqdn.com:8443
    # default is localhost:8443
    env.sslh no 
    # Check That SSL host is valid, default is yes
    env.sslp no 
    # Check That SSL peer is valid, default is yes
    env.name Site Name
    # A pretty name for the unifi site - used in graph titles.
    env.site site_string 
    # default is "default" - found when you connect to the web interface - it's the term
    # in the URL - /manage/site/site_string/dashboard

=head1 CAPABILITIES

This plugin is a multigraph plugin by default.

This plugin supports DIRTYCONFIG : L<http://guide.munin-monitoring.org/en/latest/plugin/protocol-dirtyconfig.html>

=head1 DEPENDENCIES

=over

=item WWW::Curl::Easy

Perl extension interface for libcurl

=item JSON

 JSON (JavaScript Object Notation) encoder/decoder

=back

=head1 LICENSE

Copyright (C) 2018 J.T.Sage (jtsage@gmail.com)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see L<http://www.gnu.org/licenses/>.

=head1 VERSION

Most recent version available from 

L<https://github.com/jtsage/unifi-munin-plugins>

=head1 MAGICK MARKERS

  #%# family=manual
  #%# capabilities=autoconf

=cut

use warnings;
use strict;
use utf8;

# Check dependancies
my @errorCode;
my $me = (split '/', $0)[-1];

if (! eval {require JSON; JSON->import(); 1; } ) {
	push @errorCode, "JSON module not found";
}
if (! eval {require WWW::Curl::Easy; 1;} ) {
	push @errorCode, "WWW::Curl::Easy module not found";
}

# Provide autoconf info
if ( defined($ARGV[0]) && $ARGV[0] eq "autoconf" ) {
	push @errorCode, "Requires configuration";
	print "no (", join(", " => @errorCode), ")\n";
	exit(0);
}

# Fail on not found dependancies
if ( @errorCode != 0 ) {
	die "FATAL:$me: Perl dependancies not installed (", join(", " => @errorCode), ")\n";
}

# Use multigraph by default, if it's available - allow user override
my $use_multigraph = ( $ENV{"MUNIN_CAP_MULTIGRAPH"} ) ? (
		( defined $ENV{'multigraph'} && $ENV{'multigraph'} =~ m/no/i ) ? (
			0 # User disabled
		) : (
			1 # Default Option
		)
	) : (
		0 # Not Supported By Munin
	);

# Somewhat (in)sane defaults for host, pass, etc.
#
# Note: SSL checking might not work.  My test rig does not.
my %APIconfig = (
	"user"     => (( defined $ENV{'user'} ) ? $ENV{'user'} : "ubnt"),
	"pass"     => (( defined $ENV{'pass'} ) ? $ENV{'pass'} : "ubnt"),
	"host"     => (( defined $ENV{'host'} ) ? $ENV{'host'} : "https://localhost:8443"),
	"site"     => (( defined $ENV{'site'} ) ? $ENV{'site'} : "default"),
	"sslh"     => (( defined $ENV{'sslh'} ) ? $ENV{'sslh'} : "yes"),
	"sslp"     => (( defined $ENV{'sslp'} ) ? $ENV{'sslp'} : "yes"),
	"name"     => (( defined $ENV{'name'} ) ? $ENV{'name'} : "Unnamed Site"),
);

# Set up needed API endpoints and date strings
my $APILogin  = $APIconfig{"host"} . "/api/login";
my $APILogout = $APIconfig{"host"} . "/api/logout";
my $APIPoint  = $APIconfig{"host"} . "/api/s/" . $APIconfig{"site"} . "/stat/device";
my $APIData   = "{'username':'" . $APIconfig{"user"} . "', 'password':'" . $APIconfig{"pass"} . "'}";
my $APISSLHst = ( $APIconfig{"sslh"} =~ m/no/i ) ? 0 : 2;
my $APISSLPer = ( $APIconfig{"sslp"} =~ m/no/i ) ? 0 : 1;
my $APIRawResp; my $APILogResp; my $ignore;

# Init curl.
my $curl = WWW::Curl::Easy->new() or die "FATAL:$me: WWW::Curl::Easy init failed!\n";
my $retcode;

# Set up curl, and login to API
$curl->setopt($curl->CURLOPT_POST,1);
$curl->setopt($curl->CURLOPT_COOKIEFILE,"");  # Session only cookie.
$curl->setopt($curl->CURLOPT_SSL_VERIFYPEER, $APISSLPer);
$curl->setopt($curl->CURLOPT_SSL_VERIFYHOST, $APISSLHst);
$curl->setopt($curl->CURL_SSLVERSION_TLSv1, 1);
$curl->setopt($curl->CURLOPT_URL, $APILogin);
$curl->setopt($curl->CURLOPT_POSTFIELDS, $APIData );
$curl->setopt($curl->CURLOPT_WRITEDATA, \$APILogResp);
$retcode = $curl->perform;

if ( $retcode != 0 ) {
	die "FATAL:$me: Unable to connect to API: " . $curl->strerror($retcode) . " " . $curl->errbuf . "\n";
}

my $jsonLogOBJ = JSON->new() or die "FATAL:$me: JSON init failed!\n";
my $jsonLogResp = $jsonLogOBJ->allow_nonref->utf8->relaxed->decode($APILogResp);
if ( $jsonLogResp->{"meta"}->{"rc"} ne "ok" ) {
	die "FATAL:$me: Unable to login to API - it said: " , $jsonLogResp->{"meta"}->{"msg"} , "\n";
}

# Get some API data.
$curl->setopt($curl->CURLOPT_HTTPGET,1);
$curl->setopt($curl->CURLOPT_WRITEDATA, \$APIRawResp);
$curl->setopt($curl->CURLOPT_URL, $APIPoint);
$retcode = $curl->perform;

# Decode response
my $jsonOBJ = JSON->new() or die "FATAL:$me: JSON init failed!\n";
my $jsonResp = $jsonOBJ->allow_nonref->utf8->relaxed->decode($APIRawResp);

if ( $retcode != 0 ) {
	die "FATAL:$me: Unable to fetch data from API: " . $curl->strerror($retcode) . " " . $curl->errbuf . "\n";
}


# Log back out. (Should invalidate our cookie file, just in case)
$curl->setopt($curl->CURLOPT_HTTPGET,1);
$curl->setopt($curl->CURLOPT_WRITEDATA, \$ignore);
$curl->setopt($curl->CURLOPT_URL, $APILogout);
$retcode = $curl->perform;

if ( $retcode != 0 ) {
	die "FATAL:$me: Unable to logout of API: " . $curl->strerror($retcode) . " " . $curl->errbuf . "\n";
}

# Work with the API data - grab everything we will need.
my %devList;


foreach my $device ( @{$jsonResp->{"data"}} ) {
	my $safeDevName = make_safe( $device->{"name"} );

	my @theseRadios;

	if ( $device->{"type"} eq "uap" ) {
		foreach my $thisRadio ( @{$device->{"radio_table_stats"}} ) {
			my $name = make_safe( $thisRadio->{"name"} );
			my $label = ( $thisRadio->{"channel"} < 12 ) ? "2.4Ghz" : "5Ghz";

			$_ = $device->{"stat"};

			push @theseRadios, {
				"name"  => $name,
				"label" => $label . "-" . $device->{"name"},
				"pckt"  => $_->{$name . "-rx_packets"} + $_->{$name . "-tx_packets"},
				"dret"  => $_->{$name . "-rx_dropped"} + $_->{$name . "-tx_retries"} + $_->{$name . "-tx_dropped"},
				"err"   => $_->{$name . "-rx_errors"}  + $_->{$name . "-tx_errors"},
				"type"  => $label
			};
		}
		$devList{$safeDevName} = [ $device->{"name"}, \@theseRadios ];
	}
}


if ( defined($ARGV[0]) && $ARGV[0] eq "config" ) {
	if ( $use_multigraph ) {
		print "multigraph unifi_xfer_per_radio\n";
	}
	print "graph_title Transfer per radio : " , $APIconfig{"name"} , "\n";
	print "graph_vlabel Packets/\${graph_period}\n";
	print "graph_category unifi\n";
	print "graph_args --base 1000\n";
	print "graph_info Packets per radio\n";

	foreach my $thisDev ( sort keys %devList ) {
		foreach ( @{$devList{$thisDev}[1]} ) {
			print $thisDev , "_" , $_->{"name"} , "_pack.label " , $_->{"label"} , "\n";
			print $thisDev , "_" , $_->{"name"} , "_pack.type DERIVE\n";
			print $thisDev , "_" , $_->{"name"} , "_pack.min 0\n";
			if ( $ENV{'MUNIN_CAP_DIRTYCONFIG'} ) {
				print $thisDev , "_" , $_->{"name"} , "_pack.value " , $_->{"pckt"} , "\n";
			}
		}
	}

	if ( $use_multigraph ) {
		foreach my $thisDev ( sort keys %devList ) {
			print "multigraph unifi_xfer_per_radio." , $thisDev , "\n";
			print "graph_title Transfer / radio : " , $devList{$thisDev}[0] , " : " , $APIconfig{"name"} , "\n";
			print "graph_vlabel Packets/\${graph_period}\n";
			print "graph_category unifi\n";
			print "graph_args --base 1000\n";
			print "graph_info Packets per radio\n";
			foreach ( @{$devList{$thisDev}[1]} ) {
				print $_->{"name"} , "_pkt.label " , $_->{"type"} , " Packets\n";
				print $_->{"name"} , "_pkt.type DERIVE\n";
				print $_->{"name"} , "_pkt.min 0\n";
				print $_->{"name"} , "_dret.label " , $_->{"type"} , " Dropped / Retries\n";
				print $_->{"name"} , "_dret.type DERIVE\n";
				print $_->{"name"} , "_dret.min 0\n";
				print $_->{"name"} , "_err.label " , $_->{"type"} , " Errors\n";
				print $_->{"name"} , "_err.type DERIVE\n";
				print $_->{"name"} , "_err.min 0\n";
				if ( $ENV{'MUNIN_CAP_DIRTYCONFIG'} ) {
					print $_->{"name"} , "_pkt.value "  , $_->{"pckt"} , "\n";
					print $_->{"name"} , "_dret.value " , $_->{"dret"} , "\n";
					print $_->{"name"} , "_err.value "  , $_->{"err"}  , "\n";
				}
			}
		}
	}
	exit 0;

} else {
	if ( $use_multigraph ) {
		print "multigraph unifi_xfer_per_radio\n";
	}

	foreach my $thisDev ( sort keys %devList ) {
		foreach ( @{$devList{$thisDev}[1]} ) {
			print $thisDev , "_" , $_->{"name"} , "_pack.value " , $_->{"pckt"} , "\n";
		}
	}

	if ( $use_multigraph ) {
		foreach my $thisDev ( sort keys %devList ) {
			print "multigraph unifi_xfer_per_radio." . $thisDev . "\n";
			foreach ( @{$devList{$thisDev}[1]} ) {
				print $_->{"name"} , "_pkt.value "  , $_->{"pckt"} , "\n";
				print $_->{"name"} , "_dret.value " , $_->{"dret"} , "\n";
				print $_->{"name"} , "_err.value "  , $_->{"err"}  , "\n";
			}
		}
	}
}

# Make field names safe.
sub make_safe { $_ = lc($_[0]); s/^[^a-z_]+/_/; s/\W/_/g; return ( $_ eq "root" ? "__root" : $_ ); }
