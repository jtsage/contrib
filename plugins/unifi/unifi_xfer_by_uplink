#!/usr/bin/perl
# -*- perl -*-

=encoding utf8

=head1 NAME

unifi_xfer_by_uplink - Munin plugin to display transfer statistic for 
the usg uplink (tested with a UFW, single wan port)

=head1 APPLICABLE SYSTEMS

Currently is cabable of polling the unifi line (Ubiquity) from the unifi 
API - requires direct access to the controllor API.

=head1 CONFIGURATION

You will need to supply your API login details - you may do so 
per-plugin, or using a wildcard like below:

  [unifi_*]
    env.user Controller_Username
    # default is ubnt
    env.pass Controller_Password
    # default is ubnt
    env.host https://unifi.fqdn.com:8443
    # default is localhost:8443
    env.sslh no 
    # Check That SSL host is valid, default is yes
    env.sslp no 
    # Check That SSL peer is valid, default is yes
    env.name Site Name
    # A pretty name for the unifi site - used in graph titles.
    env.site site_string 
    # default is "default" - found when you connect to the web interface - it's the term
    # in the URL - /manage/site/site_string/dashboard

=head1 CAPABILITIES

This plugin supports DIRTYCONFIG : L<http://guide.munin-monitoring.org/en/latest/plugin/protocol-dirtyconfig.html>

=head1 DEPENDENCIES

=over

=item WWW::Curl::Easy

Perl extension interface for libcurl

=item JSON

 JSON (JavaScript Object Notation) encoder/decoder

=back

=head1 LICENSE

Copyright (C) 2018 J.T.Sage (jtsage@gmail.com)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see L<http://www.gnu.org/licenses/>.

=head1 VERSION

Most recent version available from 

L<https://github.com/jtsage/unifi-munin-plugins>

=head1 MAGICK MARKERS

  #%# family=manual
  #%# capabilities=autoconf

=cut

use warnings;
use strict;
use utf8;

# Check dependancies
my @errorCode;
my $me = (split '/', $0)[-1];

if (! eval {require JSON; JSON->import(); 1; } ) {
	push @errorCode, "JSON module not found";
}
if (! eval {require WWW::Curl::Easy; 1;} ) {
	push @errorCode, "WWW::Curl::Easy module not found";
}

# Provide autoconf info
if ( defined($ARGV[0]) && $ARGV[0] eq "autoconf" ) {
	push @errorCode, "Requires configuration";
	print "no (", join(", " => @errorCode), ")\n";
	exit(0);
}

# Fail on not found dependancies
if ( @errorCode != 0 ) {
	die "FATAL:$me: Perl dependancies not installed (", join(", " => @errorCode), ")\n";
}

# Somewhat (in)sane defaults for host, pass, etc.
#
# Note: SSL checking might not work.  My test rig does not.
my %APIconfig = (
	"user"     => (( defined $ENV{'user'} ) ? $ENV{'user'} : "ubnt"),
	"pass"     => (( defined $ENV{'pass'} ) ? $ENV{'pass'} : "ubnt"),
	"host"     => (( defined $ENV{'host'} ) ? $ENV{'host'} : "https://localhost:8443"),
	"site"     => (( defined $ENV{'site'} ) ? $ENV{'site'} : "default"),
	"sslh"     => (( defined $ENV{'sslh'} ) ? $ENV{'sslh'} : "yes"),
	"sslp"     => (( defined $ENV{'sslp'} ) ? $ENV{'sslp'} : "yes"),
	"name"     => (( defined $ENV{'name'} ) ? $ENV{'name'} : "Unnamed Site"),
);

# Set up needed API endpoints and date strings
my $APILogin  = $APIconfig{"host"} . "/api/login";
my $APILogout = $APIconfig{"host"} . "/api/logout";
my $APIPoint  = $APIconfig{"host"} . "/api/s/" . $APIconfig{"site"} . "/stat/device";
my $APIData   = "{'username':'" . $APIconfig{"user"} . "', 'password':'" . $APIconfig{"pass"} . "'}";
my $APISSLHst = ( $APIconfig{"sslh"} =~ m/no/i ) ? 0 : 2;
my $APISSLPer = ( $APIconfig{"sslp"} =~ m/no/i ) ? 0 : 1;
my $APIRawResp; my $APILogResp; my $ignore;

# Init curl.
my $curl = WWW::Curl::Easy->new() or die "FATAL:$me: WWW::Curl::Easy init failed!\n";
my $retcode;

# Set up curl, and login to API
$curl->setopt($curl->CURLOPT_POST,1);
$curl->setopt($curl->CURLOPT_COOKIEFILE,"");  # Session only cookie.
$curl->setopt($curl->CURLOPT_SSL_VERIFYPEER, $APISSLPer);
$curl->setopt($curl->CURLOPT_SSL_VERIFYHOST, $APISSLHst);
$curl->setopt($curl->CURL_SSLVERSION_TLSv1, 1);
$curl->setopt($curl->CURLOPT_URL, $APILogin);
$curl->setopt($curl->CURLOPT_POSTFIELDS, $APIData );
$curl->setopt($curl->CURLOPT_WRITEDATA, \$APILogResp);
$retcode = $curl->perform;

if ( $retcode != 0 ) {
	die "FATAL:$me: Unable to connect to API: " . $curl->strerror($retcode) . " " . $curl->errbuf . "\n";
}

my $jsonLogOBJ = JSON->new() or die "FATAL:$me: JSON init failed!\n";
my $jsonLogResp = $jsonLogOBJ->allow_nonref->utf8->relaxed->decode($APILogResp);
if ( $jsonLogResp->{"meta"}->{"rc"} ne "ok" ) {
	die "FATAL:$me: Unable to login to API - it said: " , $jsonLogResp->{"meta"}->{"msg"} , "\n";
}

# Get some API data.
$curl->setopt($curl->CURLOPT_HTTPGET,1);
$curl->setopt($curl->CURLOPT_WRITEDATA, \$APIRawResp);
$curl->setopt($curl->CURLOPT_URL, $APIPoint);
$retcode = $curl->perform;

# Decode response
my $jsonOBJ = JSON->new() or die "FATAL:$me: JSON init failed!\n";
my $jsonResp = $jsonOBJ->allow_nonref->utf8->relaxed->decode($APIRawResp);

if ( $retcode != 0 ) {
	die "FATAL:$me: Unable to fetch data from API: " . $curl->strerror($retcode) . " " . $curl->errbuf . "\n";
}


# Log back out. (Should invalidate our cookie file, just in case)
$curl->setopt($curl->CURLOPT_HTTPGET,1);
$curl->setopt($curl->CURLOPT_WRITEDATA, \$ignore);
$curl->setopt($curl->CURLOPT_URL, $APILogout);
$retcode = $curl->perform;

if ( $retcode != 0 ) {
	die "FATAL:$me: Unable to logout of API: " . $curl->strerror($retcode) . " " . $curl->errbuf . "\n";
}


# Work with the API data - grab everything we will need.
my %netList;

foreach ( @{$jsonResp->{"data"}} ) {
	if ( $_->{"type"} eq "ugw" ) {

		$netList{"devName"}  = $_->{name};
		$netList{"rx_speed"} = $_->{"speedtest-status"}->{"xput_download"} * 1000000;
		$netList{"tx_speed"} = $_->{"speedtest-status"}->{"xput_upload"} * 1000000;

		foreach ( @{$_->{"port_table"}} ) {
			if ( $_->{name} eq "wan" ) {
				$netList{"rx_bytes"} = $_->{"rx_bytes"};
				$netList{"tx_bytes"} = $_->{"tx_bytes"};
			}
		}
	}
}

if ( defined($ARGV[0]) && $ARGV[0] eq "config" ) {
	print "graph_title Transfer on uplink : " . $netList{"devName"}  . " : " . $APIconfig{"name"} . "\n";
	print "graph_vlabel Bytes/\${graph_period} rcvd (-) / trans (+)\n";
	print "graph_category unifi\n";
	print "graph_args --base 1000\n";
	print "graph_info Bytes transfered\n";

	print "rx_speed.label Speedtest\n";
	print "tx_speed.label Speedtest\n";
	print "rx_bytes.label Transfered\n";
	print "tx_bytes.label Transfered\n";
	print "rx_speed.type GAUGE\n";
	print "tx_speed.type GAUGE\n";
	print "rx_bytes.type DERIVE\n";
	print "tx_bytes.type DERIVE\n";
	print "rx_speed.min 0\n";
	print "tx_speed.min 0\n";
	print "rx_bytes.min 0\n";
	print "tx_bytes.min 0\n";
	print "rx_speed.graph no\n";
	print "rx_bytes.graph no\n";
	print "tx_speed.negative rx_speed\n";
	print "tx_bytes.negative rx_bytes\n";
	if ( $ENV{'MUNIN_CAP_DIRTYCONFIG'} ) {
		print "rx_speed.value " . $netList{"rx_speed"} . "\n";
		print "tx_speed.value " . $netList{"tx_speed"} . "\n";
		print "rx_bytes.value " . $netList{"rx_bytes"} . "\n";
		print "tx_bytes.value " . $netList{"tx_bytes"} . "\n";
	}
	exit 0;

} else {
	print "rx_speed.value " . $netList{"rx_speed"} . "\n";
	print "tx_speed.value " . $netList{"tx_speed"} . "\n";
	print "rx_bytes.value " . $netList{"rx_bytes"} . "\n";
	print "tx_bytes.value " . $netList{"tx_bytes"} . "\n";
}


# Make field names safe.
sub make_safe { $_ = lc($_[0]); s/^[^a-z_]+/_/; s/\W/_/g; return ( $_ eq "root" ? "__root" : $_ ); }
