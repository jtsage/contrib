#!/usr/bin/perl
# -*- perl -*-

=encoding utf8

=head1 NAME

unifi_device_stats - Munin plugin to display system statistics
for each ubiquity / unifi device.

=head1 APPLICABLE SYSTEMS

Currently is cabable of polling the unifi line (Ubiquity) from the unifi 
API - requires direct access to the controllor API. Requires multigraph.

=head1 GRAPHS PROVIDED

This plugin provides:

 * unifi_device_cpu - CPU usage percentage
 * unifi_device_load - Load average (Switches and AP's only)
 * unifi_device_mem - Memory usage percentage
 * unifi_device_uptime - Uptime counter

=head1 CONFIGURATION

You will need to supply your API login details - you may do so 
per-plugin, or using a wildcard like below:

  [unifi_*]
    env.user Controller_Username
    # default is ubnt
    env.pass Controller_Password
    # default is ubnt
    env.host https://unifi.fqdn.com:8443
    # default is localhost:8443
    env.sslh no 
    # Check That SSL host is valid, default is yes
    env.sslp no 
    # Check That SSL peer is valid, default is yes
    env.name Site Name
    # A pretty name for the unifi site - used in graph titles.
    env.site site_string 
    # default is "default" - found when you connect to the web interface - 
    # it's the term in the URL - /manage/site/site_string/dashboard

 You may toggle individual sections of this plugin off if you prefer.

  [unifi_device_stats]
    env.showcpu no
    env.showload no
    env.showmem no
    env.showuptime no

=head1 CAPABILITIES

This plugin supports DIRTYCONFIG : L<http://guide.munin-monitoring.org/en/latest/plugin/protocol-dirtyconfig.html>

=head1 DEPENDENCIES

=over

=item WWW::Curl::Easy

Perl extension interface for libcurl

=item JSON

 JSON (JavaScript Object Notation) encoder/decoder

=back

=head1 LICENSE

Copyright (C) 2018 J.T.Sage (jtsage@gmail.com)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see L<http://www.gnu.org/licenses/>.

=head1 VERSION

Most recent version available from 

L<https://github.com/jtsage/unifi-munin-plugins>

=head1 MAGICK MARKERS

  #%# family=manual
  #%# capabilities=autoconf

=cut

use warnings;
use strict;
use utf8;

# Check dependancies
my @errorCode;
my $me = (split '/', $0)[-1];

if (! eval {require JSON; JSON->import(); 1; } ) {
	push @errorCode, "JSON module not found";
}
if (! eval {require WWW::Curl::Easy; } ) {
	push @errorCode, "WWW::Curl::Easy module not found";
}

# Provide autoconf info
if ( defined($ARGV[0]) && $ARGV[0] eq "autoconf" ) {
	push @errorCode, "Requires configuration";
	print "no (", join(", " => @errorCode), ")\n";
	exit(0);
}

# Fail on not found dependancies
if ( @errorCode != 0 ) {
	die "FATAL:$me: Perl dependancies not installed (", join(", " => @errorCode), ")\n";
}

if ( ! $ENV{"MUNIN_CAP_MULTIGRAPH"} ) {
	die "FATAL:$me: Multigraph capability required\n";
}

# Somewhat (in)sane defaults for host, pass, etc.
#
# Note: SSL checking might not work.  My test rig does not.
my %APIconfig = (
	"user"     => (( defined $ENV{'user'} ) ? $ENV{'user'} : "ubnt"),
	"pass"     => (( defined $ENV{'pass'} ) ? $ENV{'pass'} : "ubnt"),
	"host"     => (( defined $ENV{'host'} ) ? $ENV{'host'} : "https://localhost:8443"),
	"site"     => (( defined $ENV{'site'} ) ? $ENV{'site'} : "default"),
	"sslh"     => (( defined $ENV{'sslh'} ) ? $ENV{'sslh'} : "yes"),
	"sslp"     => (( defined $ENV{'sslp'} ) ? $ENV{'sslp'} : "yes"),
	"name"     => (( defined $ENV{'name'} ) ? $ENV{'name'} : "Unnamed Site"),
);

# Set up needed API endpoints and date strings
my $APILogin  = $APIconfig{"host"} . "/api/login";
my $APILogout = $APIconfig{"host"} . "/api/logout";
my $APIPoint  = $APIconfig{"host"} . "/api/s/" . $APIconfig{"site"} . "/stat/device";
my $APIData   = "{'username':'" . $APIconfig{"user"} . "', 'password':'" . $APIconfig{"pass"} . "'}";
my $APISSLHst = ( $APIconfig{"sslh"} =~ m/no/i ) ? 0 : 2;
my $APISSLPer = ( $APIconfig{"sslp"} =~ m/no/i ) ? 0 : 1;
my $APIRawResp; my $APILogResp; my $ignore;

# Init curl.
my $curl = WWW::Curl::Easy->new() or die "FATAL:$me: WWW::Curl::Easy init failed!\n";
my $retcode;

# Set up curl, and login to API
$curl->setopt($curl->CURLOPT_POST,1);
$curl->setopt($curl->CURLOPT_COOKIEFILE,"");  # Session only cookie.
$curl->setopt($curl->CURLOPT_SSL_VERIFYPEER, $APISSLPer);
$curl->setopt($curl->CURLOPT_SSL_VERIFYHOST, $APISSLHst);
$curl->setopt($curl->CURL_SSLVERSION_TLSv1, 1);
$curl->setopt($curl->CURLOPT_URL, $APILogin);
$curl->setopt($curl->CURLOPT_POSTFIELDS, $APIData );
$curl->setopt($curl->CURLOPT_WRITEDATA, \$APILogResp);
$retcode = $curl->perform;

if ( $retcode != 0 ) {
	die "FATAL:$me: Unable to connect to API: " . $curl->strerror($retcode) . " " . $curl->errbuf . "\n";
}

my $jsonLogOBJ = JSON->new() or die "FATAL:$me: JSON init failed!\n";
my $jsonLogResp = $jsonLogOBJ->allow_nonref->utf8->relaxed->decode($APILogResp);
if ( $jsonLogResp->{"meta"}->{"rc"} ne "ok" ) {
	die "FATAL:$me: Unable to login to API - it said: " , $jsonLogResp->{"meta"}->{"msg"} , "\n";
}


# Get some API data.
$curl->setopt($curl->CURLOPT_HTTPGET,1);
$curl->setopt($curl->CURLOPT_WRITEDATA, \$APIRawResp);
$curl->setopt($curl->CURLOPT_URL, $APIPoint);
$retcode = $curl->perform;

# Decode response
my $jsonOBJ = JSON->new() or die "FATAL:$me: JSON init failed!\n";
my $jsonResp = $jsonOBJ->allow_nonref->utf8->relaxed->decode($APIRawResp);

if ( $retcode != 0 ) {
	die "FATAL:$me: Unable to fetch data from API: " . $curl->strerror($retcode) . " " . $curl->errbuf . "\n";
}


# Log back out. (Should invalidate our cookie file, just in case)
$curl->setopt($curl->CURLOPT_HTTPGET,1);
$curl->setopt($curl->CURLOPT_WRITEDATA, \$ignore);
$curl->setopt($curl->CURLOPT_URL, $APILogout);
$retcode = $curl->perform;

if ( $retcode != 0 ) {
	die "FATAL:$me: Unable to logout of API: " . $curl->strerror($retcode) . " " . $curl->errbuf . "\n";
}

# Work with the API data - grab everything we will need.
my %deviceList;

foreach ( @{$jsonResp->{"data"}} ) {
	$deviceList{ make_safe( $_->{"name"} ) } = {
		"name" => $_->{"name"},
		"uptime" => $_->{'uptime'},
		"cpu" => $_->{"system-stats"}->{"cpu"},
		"mem" => $_->{"system-stats"}->{"mem"},
		"load" => ( $_->{"type"} =~ /usw|uap/ ? $_->{'sys_stats'}->{'loadavg_1'} : "unsup" )
	};
}

my %modes = (
	"cpu" =>    (( defined $ENV{"showcpu"}    && $ENV{"showcpu"}    =~ m/no/i ) ? 0 : 1 ),
	"mem" =>    (( defined $ENV{"showmem"}    && $ENV{"showmem"}    =~ m/no/i ) ? 0 : 1 ),
	"load" =>   (( defined $ENV{"showload"}   && $ENV{"showload"}   =~ m/no/i ) ? 0 : 1 ),
	"uptime" => (( defined $ENV{"showuptime"} && $ENV{"showuptime"} =~ m/no/i ) ? 0 : 1 ),
);

if ( defined($ARGV[0]) && $ARGV[0] eq "config" ) {
	if ( $modes{"uptime"} ) {
		print "multigraph unifi_device_uptime\n";
		print "graph_title Uptime : " , $APIconfig{"name"} , "\n";
		print "graph_args --base 1000 -r --lower-limit 0\n";
		print "graph_vlabel days\n";
		print "graph_category unifi\n";

		foreach ( sort keys %deviceList ) {
			print $_ , ".label " , $deviceList{$_}->{"name"} , "\n";
			if ( $ENV{"MUNIN_CAP_DIRTYCONFIG"} ) {
				print $_ , ".value " , ( $deviceList{$_}->{"uptime"} / 86400 ) , "\n";
			}
		}
	}
	if ( $modes{"cpu"} ) {
		print "multigraph unifi_device_cpu\n";
		print "graph_title CPU Usage : " , $APIconfig{"name"} , "\n";
		print "graph_args --base 1000 -r --lower-limit 0 --upper-limit 100\n";
		print "graph_vlabel %\n";
		print "graph_category unifi\n";

		foreach ( sort keys %deviceList ) {
			print $_ , ".label " , $deviceList{$_}->{"name"} , "\n";
			if ( $ENV{'MUNIN_CAP_DIRTYCONFIG'} ) {
				print $_ , ".value " , ( $deviceList{$_}->{"cpu"} ) , "\n";
			}
		}
	}
	if ( $modes{"mem"} ) {
		print "multigraph unifi_device_mem\n";
		print "graph_title Memory Usage : " , $APIconfig{"name"} , "\n";
		print "graph_args --base 1000 -r --lower-limit 0 --upper-limit 100\n";
		print "graph_vlabel %\n";
		print "graph_category unifi\n";

		foreach ( sort keys %deviceList ) {
			print $_ , ".label " , $deviceList{$_}->{"name"} , "\n";
			if ( $ENV{'MUNIN_CAP_DIRTYCONFIG'} ) {
				print $_ , ".value " , ( $deviceList{$_}->{"mem"} ) , "\n";
			}
		}
	}
	if ( $modes{"load"} ) {
		print "multigraph unifi_device_load\n";
		print "graph_title Load Average : " . $APIconfig{"name"} . "\n";
		print "graph_args -l 0 --base 1000\n";
		print "graph_vlabel load\n";
		print "graph_category unifi\n";

		foreach ( sort keys %deviceList ) {
			if ( $deviceList{$_}->{"load"} ne "unsup" ) {
				print $_ , ".label " , $deviceList{$_}->{"name"} , "\n";
				if ( $ENV{'MUNIN_CAP_DIRTYCONFIG'} ) {
					print $_ , ".value " , ( $deviceList{$_}->{"load"} ) , "\n";
				}
			}
		}
	}

	exit 0;

} else {

	if ( $modes{"uptime"} ) {
		print "multigraph unifi_device_uptime\n";

		foreach ( sort keys %deviceList ) {
			print $_ , ".value " , ( $deviceList{$_}->{"uptime"} / 86400 ) , "\n";
		}
	}
	if ( $modes{"cpu"} ) {
		print "multigraph unifi_device_cpu\n";

		foreach ( sort keys %deviceList ) {
			print $_ , ".value " , ( $deviceList{$_}->{"cpu"} ) , "\n";
		}
	}
	if ( $modes{"mem"} ) {
		print "multigraph unifi_device_mem\n";

		foreach ( sort keys %deviceList ) {
			print $_ , ".value " , ( $deviceList{$_}->{"mem"} ) , "\n";
		}
	}
	if ( $modes{"load"} ) {
		print "multigraph unifi_device_load\n";

		foreach ( sort keys %deviceList ) {
			if ( $deviceList{$_}->{"load"} ne "unsup" ) {
				print $_ , ".value " , ( $deviceList{$_}->{"load"} ) , "\n";
			}
		}
	}
}

# Make field names safe.
sub make_safe { $_ = lc($_[0]); s/^[^a-z_]+/_/; s/\W/_/g; return ( $_ eq "root" ? "__root" : $_ ); }